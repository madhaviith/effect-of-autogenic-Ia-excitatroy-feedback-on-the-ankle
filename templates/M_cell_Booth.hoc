//Generated file
{xopen("tools.hoc")}
public soma
create soma[1]
public nsoma
public dendrite
create dendrite[1]
public ndendrite
public node
create node[1]
public nnode
public nclist, synlist
objectvar nclist, synlist
public x, y, z
public position
public connect2target
public synapse


//init function
proc init() {localobj r,rmechanism,soma_start_list,soma_start,soma_end_list,soma_end,dendrite_start_list,dendrite_start,dendrite_end_list,dendrite_end,node_start_list,node_start,node_end_list,node_end
r=new Random(neuroid_random())
rmechanism=new Vector(2)
x = y = z = 0
nclist = new List()
synlist = new List()
nsoma=1
create soma[nsoma]
soma_start_list = new List()
soma_start = new Vector(4)
soma_start.x[0] = -15.0
soma_start.x[1] = 0
soma_start.x[2] = 0
soma_start.x[3] = 30.0
soma_start_list.append(soma_start)
soma_end_list = new List()
soma_end = new Vector(4)
soma_end.x[0] = 15.0
soma_end.x[1] = 0
soma_end.x[2] = 0
soma_end.x[3] = 30.0
soma_end_list.append(soma_end)
a=r.normal(0,5)
mechanism_range("soma","pas",rmechanism)
soma_pas_start = rmechanism.x[0]
soma_pas_end = rmechanism.x[1]
mechanism_range("soma","naf",rmechanism)
soma_naf_start = rmechanism.x[0]
soma_naf_end = rmechanism.x[1]
mechanism_range("soma","Kdr",rmechanism)
soma_Kdr_start = rmechanism.x[0]
soma_Kdr_end = rmechanism.x[1]
mechanism_range("soma","CaN",rmechanism)
soma_CaN_start = rmechanism.x[0]
soma_CaN_end = rmechanism.x[1]
mechanism_range("soma","KCa",rmechanism)
soma_KCa_start = rmechanism.x[0]
soma_KCa_end = rmechanism.x[1]
for i=0,nsoma-1 {
soma[i] {
  if ((i>=soma_pas_start*nsoma) && (i<soma_pas_end*nsoma)) {
    insert pas
    g_pas=0.0051
    e_pas=-60
  }
  if ((i>=soma_naf_start*nsoma) && (i<soma_naf_end*nsoma)) {
    insert naf
    gnabar_naf=1.2
  }
  if ((i>=soma_Kdr_start*nsoma) && (i<soma_Kdr_end*nsoma)) {
    insert Kdr
    gkdrbar_Kdr=1
  }
  if ((i>=soma_CaN_start*nsoma) && (i<soma_CaN_end*nsoma)) {
    insert CaN
    gcanbar_CaN=0.014
  }
  if ((i>=soma_KCa_start*nsoma) && (i<soma_KCa_end*nsoma)) {
    insert KCa
    gkcabar_KCa=0.005
  }
  ena=55
  diam=30
  cm=1
  eca=80
  nseg=1
  L=30
  ek=-80
  Ra=200
  pt3dclear() pt3dadd(soma_start_list.o(i).x[0],soma_start_list.o(i).x[1],soma_start_list.o(i).x[2],soma_start_list.o(i).x[3])  pt3dadd(soma_end_list.o(i).x[0],soma_end_list.o(i).x[1],soma_end_list.o(i).x[2],soma_end_list.o(i).x[3]) 
}
}
ndendrite=1
create dendrite[ndendrite]
dendrite_start_list = new List()
dendrite_start = new Vector(4)
dendrite_start.x[0] = -15.0
dendrite_start.x[1] = 0
dendrite_start.x[2] = 0
dendrite_start.x[3] = 12.0
dendrite_start_list.append(dendrite_start)
dendrite_end_list = new List()
dendrite_end = new Vector(4)
dendrite_end.x[0] = -1015.0
dendrite_end.x[1] = 0
dendrite_end.x[2] = 0
dendrite_end.x[3] = 12.0
dendrite_end_list.append(dendrite_end)
mechanism_range("dendrite","pas",rmechanism)
dendrite_pas_start = rmechanism.x[0]
dendrite_pas_end = rmechanism.x[1]
mechanism_range("dendrite","CaL",rmechanism)
dendrite_CaL_start = rmechanism.x[0]
dendrite_CaL_end = rmechanism.x[1]
mechanism_range("dendrite","CaN",rmechanism)
dendrite_CaN_start = rmechanism.x[0]
dendrite_CaN_end = rmechanism.x[1]
mechanism_range("dendrite","KCa",rmechanism)
dendrite_KCa_start = rmechanism.x[0]
dendrite_KCa_end = rmechanism.x[1]
for i=0,ndendrite-1 {
dendrite[i] {
  if ((i>=dendrite_pas_start*ndendrite) && (i<dendrite_pas_end*ndendrite)) {
    insert pas
    e_pas=-60
    g_pas=0.00051
  }
  if ((i>=dendrite_CaL_start*ndendrite) && (i<dendrite_CaL_end*ndendrite)) {
    insert CaL
    gcalbar_CaL=0.00033
  }
  if ((i>=dendrite_CaN_start*ndendrite) && (i<dendrite_CaN_end*ndendrite)) {
    insert CaN
    gcanbar_CaN=0.0003
  }
  if ((i>=dendrite_KCa_start*ndendrite) && (i<dendrite_KCa_end*ndendrite)) {
    insert KCa
    gkcabar_KCa=0.0008
  }
  diam=12
  eca=80
  ek=-80
  nseg=1
  L=1000
  Ra=200
  pt3dclear() pt3dadd(dendrite_start_list.o(i).x[0],dendrite_start_list.o(i).x[1],dendrite_start_list.o(i).x[2],dendrite_start_list.o(i).x[3])  pt3dadd(dendrite_end_list.o(i).x[0],dendrite_end_list.o(i).x[1],dendrite_end_list.o(i).x[2],dendrite_end_list.o(i).x[3]) 
}
}
nnode=1
create node[nnode]
node_start_list = new List()
node_start = new Vector(4)
node_start.x[0] = 15.0
node_start.x[1] = 0
node_start.x[2] = 0
node_start.x[3] = 4.0
node_start_list.append(node_start)
node_end_list = new List()
node_end = new Vector(4)
node_end.x[0] = 515.0
node_end.x[1] = 0
node_end.x[2] = 0
node_end.x[3] = 4.0
node_end_list.append(node_end)
for i=0,nnode-1 {
node[i] {
  nseg=1
  diam=4.0
  L=500
  pt3dclear() pt3dadd(node_start_list.o(i).x[0],node_start_list.o(i).x[1],node_start_list.o(i).x[2],node_start_list.o(i).x[3])  pt3dadd(node_end_list.o(i).x[0],node_end_list.o(i).x[1],node_end_list.o(i).x[2],node_end_list.o(i).x[3]) 
}
}
connect soma[0](0.0), dendrite[0](1.0)
connect node[0](0.0), soma[0](1.0)
}


//position function
proc position() {
    soma for i = 0, n3d()-1 {
        pt3dchange(i, $1-x+x3d(i), $2-y+y3d(i), $3-z+z3d(i), diam3d(i))
    }
    dendrite for i = 0, n3d()-1 {
        pt3dchange(i, $1-x+x3d(i), $2-y+y3d(i), $3-z+z3d(i), diam3d(i))
    }
    node for i = 0, n3d()-1 {
        pt3dchange(i, $1-x+x3d(i), $2-y+y3d(i), $3-z+z3d(i), diam3d(i))
    }
    x = $1 y = $2 z = $3
}


//connect2target function
obfunc connect2target() {localobj nc
  node[nnode-1] nc = new NetCon(&v(1), $o1)
  nc.threshold = -20
  if (numarg() == 2) { $o2 = nc } // for backward compatibility
  return nc
}


//synapse function
obfunc synapse() {localobj syn
  nsoma = 1
  ndendrite = 1
  nnode = 1
  if(strcmp($s1,"IAfex") == 0) {
    dendrite[int(poisson_index(4,0,ndendrite-1))] syn = new ExpSyn(uniform_position())
    syn.tau = 0.5
    syn.e = 0
  } else if(strcmp($s1,"EXINex") == 0) {
    dendrite[int(poisson_index(4.2,0,ndendrite-1))] syn = new ExpSyn(uniform_position())
    syn.tau = 0.5
    syn.e = 0
  } else if(strcmp($s1,"IAIntin") == 0) {
    soma[int(0)] syn = new Exp2Syn(0.5)
    syn.tau2 = 2
    syn.tau1 = 1.5
    syn.e = -75
  } else if(strcmp($s1,"EES") == 0) {
    node[int(3)] syn = new ExpSyn(0.5)
    syn.tau = 0.1
    syn.e = 50
  } else if(strcmp($s1,"GLU") == 0) {
    soma[int(0)] syn = new GLU(0.5)
  } else if(strcmp($s1,"GABA") == 0) {
    soma[int(0)] syn = new GABA(0.5)
  }
  synlist.append(syn)
  return syn
}


func poisson_index(){localobj r
  a=0
  r=new Random(neuroid_random())
  temp=r.poisson($1)
  for j=1,5{
    temp = r.repick()
    a+=temp
  }
  a = int(a/5)-2
  if (a<$2) {a=$2}
  if (a>$3) {a=$3}
  return a
}


func uniform_position() {localobj r
  r=new Random(neuroid_random())
  b=r.uniform(0,1)
  return b
}


proc mechanism_range() {localobj rvec,f
  rvec = $o3
  rvec.x[0] = 0.0
  rvec.x[1] = 1.0
  strdef segm,mech
  f = new File()
  f.ropen("M_cell_Booth.dat")
  if (!f.isopen()){
    return
  }
  while (!f.eof()) {
    f.scanstr(segm)
    f.scanstr(mech)
    if ((strcmp(segm,$s1) == 0) && (strcmp(mech,$s2) == 0)){
        rvec.x[0] = f.scanvar()
        rvec.x[1] = f.scanvar()
    } else {
        f.gets(segm)
    }
  }
  f.close()
}


