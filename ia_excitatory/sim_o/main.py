#######################################################################################
#  This code is part of project NEUROiD developed at Spine Labs
#  Dept. of BME,
#  IIT Hyderabad
#  www.iith.ac.in/~mohanr
#
#  Revision History
#  -----------------------
#   Name             Date            Changes
#   ---------       -------     ----------------------
#   Raghu S Iyengar  Aug 2015      Initial Creation
#   Madhav Vinodh    Oct 2019      Made changes to handle multiple motoneurons, 
#                                  Added finctions to calculate the 
#
#   
#
######################################################################################

######################################################################################
# this code runs the neuronal simulations 
#
# Input:
#    - hoc file containing the neurons and connections (/neuroid.hoc -file autogenerated on NEUROiD platform)
#    - a setup file specifying some settings (/setup.json)
#    - neuroid_osim_map -to connect the motoneurons with the musculoskeletal model (../moto_osim_musc_map.xlsx)
#    - osim_neuroi_map -to connect the grd_neurons with the afferent neurons
#
#
# Output:
#  .npz files of neruon states in the output simulation directory after simulation is done
#
#
###############################################################################

import os,json,sys, socket, time, random
from neuron import h
import numpy as np
import pandas as pd
import math

# Path of current file
mypath = os.path.dirname(os.path.abspath(__file__))
#print (mypath)



# Map the motoneurons with the msucles
load_neuroid_osim_map = pd.read_excel(mypath + "/../moto_osim_musc_map.xlsx",sheet_name="moto_osim_musc_map")

# Map the msucle proprioceptors with the drg neurons
load_osim_drg_map = pd.read_excel(mypath + "/../osim_musc_drg_map.xlsx",sheet_name="osim_musc_drg_map")
osim_drg_map = load_osim_drg_map.copy()

# osim msucle ids to sysnthesisze the neuroid to osim message
osim_muscles = list(set(load_neuroid_osim_map['muscle_name'].to_list()))
#print load_neuroid_osim_map

#function to send the muscle activations to musculoskeletal model and receive the afferent firings in return via client-server socket
def one_step_osim(neuroid_osim_msg,testing_mode):
    s = socket.socket()         # Create a socket object
    s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    host = socket.gethostname() # Get local machine name
    print (host)
    port = 50003
    s.connect((host, port))

    # format for neuiroid_osim_msg is following:
    # [{"msucle_name":16,"activation":fact},{"muscle_name":17,"activation":eact}]
    #s.send(json.dumps(neuroid_osim_msg))
    neuroid_osim_msg = str(neuroid_osim_msg)
    s.send(neuroid_osim_msg.encode('utf-8'))
    
    if testing_mode == "open_loop":
       osim_neuroid_msg = "open_loop testing underway, NO feedback from the musculoskeleton" 
       #print osim_neuroid_msg
    elif testing_mode == "close_loop":
         #receive afferent firings in the following
         print ("close_loop")
         jsstr = s.recv(1024000)
         jsmsg = jsstr.decode('utf-8')
         osim_neuroid_msg = eval(jsmsg)
    s.close()    
    return osim_neuroid_msg

class Neuroid:
    """
    class: Neuroid
    represents an instance of NEURON simulation

    The functions in this file are invoked when the user loads a simulation setup
     json file from the browser interface.
    An instance of this class is created to run the experiment.
    An experiment may have multiple simulation runs and all of those are
     handled in this file
    On successful completion of experiemnt simulation, This class also stores the 
     results in npz files, which is later used by plot.py
    """

    def __init__(self):
        """
        function: __init__

        sets up the NEURON HOC environment and initialize variables man_L5_GasSol9_L_aMot_gaslat_cell
        """
        self.h = h
        # neuroid.hoc is generated by the nodejs server code
        #  It uses the spine.json and setup json file to create this
        #  neuroid.hoc represents the model in a hoc file format,
        #  while this file parses the setup json file and performs experiment
        #  on the hoc model
        
        # setup json file where the experiment details are present
        setupf = open(mypath+"/setup.json") 
        self.setup = json.loads(setupf.read())
        setupf.close()
        
        # load neuroid.hoc
        self.h.xopen(mypath+"/neuroid.hoc")
        self.h('objref pc')
        self.h('pc = new ParallelContext()') #comment@madhav non functional call, for future use with parallel computing
        self.h('PcID = pc.id // for python') #comment@madhav non functional call, for future use with parallel computing 
        self.h('Nhost = pc.nhost // for python')
        self.h('celsius=37')
        self.h('dt=0.05')
        self.h('v_init=-65')
        self.simid = 0
        self.dt = self.setup["runs"]["dt"]
        
        self.vrecord = {}
        self.iclrecord = {}

        #self.osim = False #why is this ??
        if "opensim" in self.setup["setup"] and self.setup["setup"]["opensim"]["enable"] == "True":
            self.osim = True
       

    def _set_simid(self, i):
        """
        function: __set_simid
        sets the simulation id

        An experiment may involve multiple simulation runs, each with different parameters
        setup.json file contains details of number of simulations for an experiment
        This function simply sets the current simulation run id into a class variable
        """
        self.simid = i

    def reset(self):
        """
        function: reset

        reset the state of system before a simulation run starts
        """
        self.h.finitialize(-65)
        self.tskip = 0
        self.h.t = 0
        self.h.tstop = self.setup["runs"]["tstop"][self.simid]
        #comment@madhav: network_init will be required only when there is a 
        #defined concensus what neuronal targets are connected to 
        #self.network_init(reset=1)
        
        for response in self.setup["responses"]:
            if response["type"] == "variable":
                ncells = int(eval("h.n"+response["target"]["obj"]))
                self.vrecord[str(self.simid) + "_" + response["type"]+"_"+response["id"]] = np.zeros((int(self.h.tstop/self.dt),ncells))
                
                    
    #function to reset the netstim stimulation of the 
    #for the activation of motoneuons, we can call EES as proxy to cortical drive
    #randomize the stimulaion affinity to the motoneuron cluster
                
    def run(self):
        
        """
        function: run

        This function performs the NEURON simulation
          - Initializes python variables that store the spike train and inputs in every time step
          - In a while loop:
            - Advance the simulation by one time step
            - Calculate the activation for relevant muscles using motoneuron axon potentials
            - Advance the musculo-sketal model by one step
            - Afferent firing is used to stimulate the IN and MN, closing the loop
            - Update python variables with the recorded values for that timestep
        """
        #print ("RUN section began")
        
        
        def calc_spike_freq(spikes, count, time_window, per_cells):
            """
            function: calc_spike_freq
            spikes - spike train as a python list
            count - current simulation step number

            Calculates the spike frequency (in Hz) given the spike train
            The frequency is obtained using the spike train over the past 30ms
            """
            avg_time = time_window #(ms)
            nrows = int(avg_time/self.dt) # for 1ms
            ncells = spikes.shape[1]
            spikes = spikes[count-nrows+1:count,:]
            nspikes = np.sum(spikes)/ncells #number average spike frequency
            sfreq = (1000.0*nspikes)/avg_time
            return sfreq

        def calc_activation(freq,prev_act):
            """
            function: calc_activatin
              freq - frequency of spike train
              prev_act - previous activation of the muscle

            Calculates the activation (a value between 0.0 and 1.0) for the muscle
            This is sent to OpenSim to activate corresponding muscle
            The new calculated value uses a (1-alpha) update to reduce noise
            """
            act = 1.0/(1+math.exp(-0.2*(freq-20)))
            alpha = 0.2
            act = alpha*act + (1.0-alpha)*prev_act
            return act
        
        #funtion to find the drg neuron given the id received from neuroid_opensim_glue.py 
        def find_drg_name(idx):
            name = osim_drg_map.iloc[idx]['target_drg']
            return name
        
        #function to set the affetent stimulation frequency 
        def set_afferent_stim_Hz(osim_neuroid_msg):
            for each in osim_neuroid_msg:
                drg_name = find_drg_name(int(each))
                drg_stim_list = eval("h." + drg_name + "_stim")
                if osim_neuroid_msg[each] > 0.0:
                   drg_stim_list.pp.interval = int(1000/osim_neuroid_msg[each])
                   print (drg_stim_list.pp.interval)
                   
        #function to set to activate a particluar drg_neuron      
        def set_afferent_stim_wt(osim_neuroid_msg,wt):
            for each in osim_neuroid_msg:
                drg_name = find_drg_name(int(each))
                #print drg_name
                drg_stim_list = eval("h." + drg_name + "_stim_list")
                if osim_neuroid_msg[each] > 0.0:
                    for i in range(0,len(drg_stim_list)):
                        drg_stim_list.object(i).weight[0] = wt


        self.time = []
        self.spikes = {}
        self.ees_inp = {}
        self.aff = {} 
        self.tskip = 0
        self.h.finitialize(-65)
        nts = int((self.h.tstop-self.tskip)/self.dt)
 
        #create a time array and use ths array as index to create dataframes
        #use this mostly  
        self.motoneurons = self.setup["motoneurons"]
        self.time_array = np.linspace(0,h.tstop,int(self.h.tstop/self.dt))
        self.moto_act_df = pd.DataFrame(0, index = self.time_array, columns = self.motoneurons)
        self.muscle_act_df = pd.DataFrame(0, index = self.time_array, columns = osim_muscles)
        #self.cum_neu_act_df = pd.DataFrame(0, index = self.time_array, columns = osim_muscles)
        
        #convert dtype of dataframes to floating types
        self.muscle_act_df = self.muscle_act_df.astype(float)
        
        #create empty numpy arrays for just motoneurons to fill them at later time
        self.moto_spikes = {}
        for moto_neuron_grp in self.motoneurons:
            moto_spikename = "spike" + "_" + moto_neuron_grp #eg: spike_Human_L2_Q9_L_aMotrecf #190 motoneurons
            ncells = int(eval("h.n"+ moto_neuron_grp))
            self.moto_spikes[moto_spikename] = { "record": np.zeros((nts,ncells)), #time_bin x cell_num #record contains a particular cell_groups's all the spikes vs time
                                           "prev": np.zeros(ncells) }
        
        for response in self.setup["responses"]:
            if response["type"] == "spike":
                spikename = response["type"]+"_"+response["id"]
                ncells = int(eval("h.n"+response["target"]["region"]))
                self.spikes[spikename] = { "record": np.zeros((nts,ncells)),
                                           "prev": np.zeros(ncells) }
                
        #this section for now can be same
        for inp in self.setup["inputs"]:
            if inp["type"] == "ees":
                self.ees_inp[str(self.simid) + "_" + inp["type"]+"_"+inp["id"]] = np.zeros((int(self.h.tstop/self.dt),1))
                
            
                
        #no changes required
        if not "singlecell" in self.setup["setup"]:
            pass
        count = 0
        while (self.h.t<self.h.tstop) and (count < nts): 
            

            print ("while loop started,iteration = ", count)
            #print "time_by_array=", self.time_array[count]
            print (count, nts, self.h.tstop)
            #self._set_input(count)
            self.h.pc.psolve(self.h.t+self.dt)
            
            #create empty dictionaries to store freqs and activations for each time step in loop
            self.moto_osim_musc_map_sim = load_neuroid_osim_map.copy()
            self.moto_osim_musc_map_sim.set_index("source_motoneuron", inplace=True)
            self.moto_osim_musc_map_sim["moto_firing_freq"] = 0.0
            self.moto_osim_musc_map_sim["musc_activation"] = 0.0
            
            if "singlecell" in self.setup["setup"]:
                pass
            else:
                
                # If experiment needs to interact with a OpenSim musculo-skeletal model (opensim)
                # Calculate the spike frequency using the average membrane potentials
                # Calculate the "activations" for the corresponding muscles
                # (This is a value between 0 and 1, as expected by OpenSim)
                # Advance the OpenSim model by one step
                # Using the afferent PPS, set the stimulation of feedback loop
                if self.osim == True:

                    #three steps########################################################### 
                    #step 1 : calculate spikes_freq for each motoneuron passed in setup.json 
                    #step 2 : calculate the muscle_activation that need to be sent to osim model
                    #step 3 : synthesize the neuroid_osim message 
                    #######################################################################
                    
                    #step 1 and step 2
                    for each_moto_grp in self.moto_spikes:
                        #print each_moto_grp
                        moto_grp_name = each_moto_grp.lstrip('spike_') #obtain the moto cell group by stripping the ('spike_')
                        #print moto_grp_name
                        
                        #print self.moto_spikes["spike_Human_L5_GasSol9_L_aMot_gaslat"]["record"]
                        #calculate the fring frequency at every time step or at given intervals, determine from system understanding
                        #calc_spike_freq(spikes, count, time_window, per_cells
                        moto_grp_firin_freq = calc_spike_freq(self.moto_spikes[each_moto_grp]["record"],count,self.setup["runs"]["window"],1)
                        #print moto_grp_firin_freq
                        
                        #moto_osim_musc_map_sim is filled at every time step
                        #update the osim_musc_map_sim dataframe using enssemble firing frequency of a particular cell group
                        self.moto_osim_musc_map_sim.at[moto_grp_name,'moto_firing_freq'] = moto_grp_firin_freq #identify what motoneuron and update only those
                        
                        #update the muscle activation dataframe #track by iterator i.e count and motoneuron string
                        #self.moto_osim_musc_map_sim.at[moto_grp_name,'musc_activation'] = float(curr_act_moto_grp)
                        self.moto_osim_musc_map_sim.at[moto_grp_name,'musc_activation'] = float(moto_grp_firin_freq/100)
                        #print self.moto_osim_musc_map_sim
                        
                    #get activations by all motoneuron groups that are targetted to a particular muscle.
                    #moto_osim.loc[moto_osim["muscle_name"]=='gaslat_l']['muscle_acts'].mean()
                    #sysnthesize osim message in this loop
                    #step 3
                    neuroid_osim_msg = []
                    for each_osim_musc in osim_muscles:
                        
                        #get the average activation from the moto_osim_musc_map_sim- segmental summation or mean
                        osim_muscle_act = self.moto_osim_musc_map_sim.loc[self.moto_osim_musc_map_sim["muscle_name"]== each_osim_musc]['musc_activation'].mean()
                        
                        self.muscle_act_df.at[self.time_array[count],each_osim_musc] = float(osim_muscle_act) 
    
                        #extract osim muscle_name and id
                        osim_muscle_id = self.moto_osim_musc_map_sim.loc[self.moto_osim_musc_map_sim["muscle_name"]== each_osim_musc]['index_number'].to_list()[0]

                        #neuroid_osim message
                        neuroid_osim_msg.append({'id' : osim_muscle_id, 'act': osim_muscle_act})
                    
                    if count % 5 == 0:
                        
                        osim_neuroid_msg = one_step_osim(neuroid_osim_msg,testing_mode=self.setup["setup"]['testing_mode']) #push this open_loop/close_loop option to the setup.json
                        #print osim_neuroid_msg 
                        if self.setup["setup"]['testing_mode'] == 'close_loop':
                            
                            #to turn on the designated afferent 
                            set_afferent_stim_wt(osim_neuroid_msg,1)
                            
                            #to turn on set the afferent frequency 
                            set_afferent_stim_Hz(osim_neuroid_msg)
                        
                        #set afferent feed back at different times 
                        ################################################################
                        ################################################################
                        #Afferent feedback block comes here#############################
                        #insert design a function/ or call here#########################        
                        ################################################################        
                else:
                    # If we are using our in-house ankle model, call ankle_adv_hoc
                    # to advace the model by one step
                    self.h('ankle_adv_hoc(avgFlexV, avgExtV, taga_pps)')
                    
                # If LFP is enabled, advance the LFP calculations by one step
                if "lfp" in self.setup["setup"] and self.setup["setup"]["lfp"]["enable"] == "True":
                    if self.simid in  self.setup["setup"]["lfp"]["plot_run_ids"]:
                        self.lfp.lfp_advance()


            #Store the "responses", "inputs" and "spike trains" in python variables
            #for current step
            for response in self.setup["responses"]:
                if response["type"] == "variable":
                    ncells = int(eval("h.n"+response["target"]["obj"]))
                    for i in range(int(ncells)):
                        self.vrecord[str(self.simid) + "_" + response["type"]+"_"+response["id"]][count,i] = eval('h.'+response["target"]["obj"]+'_cells[' + str(i) + '].'+response["target"]["member"])
            
            
            for spk in self.spikes:
                nspikes = eval("h.record_"+spk)
                ncells = self.spikes[spk]["prev"].shape[0]
                for i in range(int(ncells)):
                    self.spikes[spk]["record"][count,i] = nspikes[i].size() - self.spikes[spk]["prev"][i]
                    self.spikes[spk]["prev"][i] = nspikes[i].size()
            
            #this sections counts the spikes for all the motoneurons passed in the setup.json and are pushed into respective numpy arrays
            for each_moto_spk in self.moto_spikes:
            #for each_moto_grp in self.spikes:
                spike_vec = eval("h.record_"+ each_moto_spk) #evaluate the hoc statements, #here assign the hoc's vector class to spike_vec 
                ncells = eval("h.n" + each_moto_spk.lstrip('spike_')) #here assign the number of cells -------------
                for i in range(int(ncells)):
                    self.moto_spikes[each_moto_spk]["record"][count,i] = spike_vec[i].size() - self.moto_spikes[each_moto_spk]["prev"][i]
                    self.moto_spikes[each_moto_spk]["prev"][i] = spike_vec[i].size()
                    
            self.time.append(self.h.t)
            count = count+1
        #print count
    
    #functions to output the neuronal states 

    def output(self):
        """
        function: output

        Save the results of simulation into npz files
        This function parses the setup["responses"] section to identify the
         variables that have to be saved into npz files.  Inputs defined in
         setup["inputs"] section are also saved
        """
        def save_variable(response):
            """
            function: save_variable
              response - setup["response"][i]

            This function saves a NEURON variable (Vector) into npz files
            """
            resp_cg = eval("h.record_"+response["type"]+"_"+response["id"])
            variable_cg = np.zeros((len(self.time),len(resp_cg)))
            for i in range(len(resp_cg)-1):
                vvec = resp_cg[i]
                for j in range(0,int(vvec.size())-int(self.tskip/self.dt)-1):
                    variable_cg[j][i] = vvec.x[j]
            fname = mypath + "/output/save_"+ str(self.simid) + "_" + response["type"]+"_"+response["id"]
            np.save(fname, self.vrecord[str(self.simid)+'_'+response["type"]+"_"+response["id"]])
        
        #use this to record any other neuron other moto neuron 
        #works only if the neuron is not an artificial one
        def save_spike(response):
            """
            function: save_spike
              response - setup["response"][i]

            This function saves the recorded spike trains
            into npz files
            """
            spikename = response["type"]+"_"+response["id"]
            spikes_cg = self.spikes[spikename]["record"]
            fname = mypath + "/output/save_"+ str(self.simid) + "_" + response["type"]+"_"+response["id"]
            np.save(fname, spikes_cg)
            
        def save_moto_spike(response):
            """
            function: to save all motoneuron's spiking data invariably for all motoneurons
            input: pass the response requested for in the setup.json 
            output: all 
            """
            spikename = "spike_" + response["target"]["region"]  #spike_Human_L2_Q9_L_aMotrecf
            spikes_cg = self.moto_spikes[spikename]["record"]
            fname = mypath + "/output/save_"+ str(self.simid) + "_" + spikename 
            np.save(fname, spikes_cg)
            
                        
        def save_voltage(response):
            """
            function: save_voltage
              response - setup["response"][i]

            This function saves the recorded voltages (membrane potential) 
            into npz files	
            """
            resp_cg = eval("h.record_"+response["type"]+"_"+response["target"]["region"]+"_"+response["target"]["segment"]+"_"+response["id"])
            voltage_cg = np.zeros((len(self.time),len(resp_cg)))
            for i in range(len(resp_cg)):
                vvec = resp_cg[i]
                for j in range(0,int(vvec.size())-int(self.tskip/self.dt)-1):
                    voltage_cg[j][i] = vvec.x[j]
            fname = mypath + "/output/save_"+ str(self.simid) + "_" + response["type"]+"_"+response["target"]["region"]+"_"+response["target"]["segment"]+"_"+response["id"]
            np.save(fname, voltage_cg)
            
        def save_muscle_act():
            fname = mypath + "/output/muscle_act_data_"
            self.muscle_act_df.to_excel(fname+".xlsx")

        # parse the setup["responses"] section and invoke appropriate
        #  functions to save the results into npz files
        for response in self.setup["responses"]:
            if response["type"] == "voltage":
                save_voltage(response)
            elif response["type"] == "spike":
                save_spike(response)
                save_moto_spike(response)
                save_muscle_act()
            elif response["type"] == "variable":
                save_variable(response)
        
        # Save the variable containing simulation time steps
        fname = mypath + "/output/save_time"
        np.save(fname, self.time)
        fthand = open(mypath + "/output/time.dat", "w")
        for x in range(len(self.time)):
            fthand.write(str(self.time[x])+"\n")
        fthand.close()
        

# This file takes no command line arguments
if __name__ == '__main__':
    # Create an instance of Neuroid
    neuroid = Neuroid()
    print ("yes")
    # NEUROiD can support a single simulation run for an experiment
    #  or multiple simulation runs for an experiment
    # For e.g., to obtain the spinal reflex recruitment curves, we need to run
    #  multiple simulation runs by changing the input stimulation current
    #  NEUROiD allows a single setup json file to specify all the simulation
    #  runs and perform the experiment
    # len(neuroid.setup["runs"]["tstop"]) is the number of simulation runs for
    #  current experiment
    num_simulation_runs = len(neuroid.setup["runs"]["tstop"])
    
    for i in range(num_simulation_runs):
        print("Starting simulation run: "+str(i+1)+" of "+str(num_simulation_runs))
        sys.stdout.flush()
        neuroid._set_simid(i)
        
        print (i)
        neuroid.reset()

        neuroid.run()
        neuroid.output()
