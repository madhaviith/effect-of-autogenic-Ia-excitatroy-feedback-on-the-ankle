#######################################################################################
#  This code is part of project NEUROiD developed at Spine Labs
#  Dept. of BME,
#  IIT Hyderabad
#  www.iith.ac.in/~mohanr
#
#  Revision History
#  -----------------------
#   Name             Date            Changes
#   ---------       -------     ----------------------
#   Raghu S Iyengar  Aug 2015      Initial Creation
#   Madhav Vinodh    Oct 2019      Made changes to handle multiple muscles, motoneurons
#                                  
#
#   
#
######################################################################################

######################################################################################
# The file is invoked from $NEUROiD_HOME/server_client/server/node_modules/neuron.js
# Here, the user input setup file for the experiment (example of such
#  setup json files is in $NEUROiD_HOME/input/simulation/demos) is
#  parsed and the NEURON simulation is performed
# 
# Input:
#  Input to this script is the
#    - generated neuroid.hoc file (generated by nodejs server)
#    - user input setup json file
# Output:
#  .npz files in the output simulation directory after simulation is done
#
# usage:
#    python main.py
#
# To run the experiment and obtain the outputs:
#  - NEURON environment is setup
#  - neuroid.hoc (generated model) is loaded into the environment
#  - setup json (for experiment definition) file is parsed
#    - "inputs" section is parsed and the stimulation inputs to the model is setup
#    - "responses" section is parsed to define the measurement probes
#    - "runs" section is parsed to obtain the details of simulation runs
#    - NEURON simulation is performed
#    - Results are written to npz files
#
# On successful completion of this script, we will have a set of npz files generated
# in the output directory under $NEUROiD_HOME/output/neuroid_<user>/sim<id>
#
###############################################################################

import os,json,sys, socket, time, random
from neuron import h
import numpy as np
import pandas as pd
from plot import *
import lfp
import math

# Path of current file
mypath = os.path.dirname(os.path.abspath(__file__))
print mypath
print "yes i am ok"
# Make this True if main.py is used for parameter search
# Will remain False for most of the experiments
SEARCHING=False
sys.path.insert(0, '/home/neurowiz/Desktop/NEUROiD_close_loop_ankle_IOP/model/gen')
from utils import *


#neuroid_osim map
load_neuroid_osim_map = pd.read_excel(get_moto_osim_musc_map_file(),sheetname="moto_osim_musc_map")
load_osim_drg_map = pd.read_excel(get_osim_musc_drg_map_file(),sheetname="osim_musc_drg_map")
osim_drg_map = load_osim_drg_map.copy()
#print osim_drg_map
osim_muscles = list(set(load_neuroid_osim_map['muscle_name'].to_list()))
#print load_neuroid_osim_map

 
#send the file locatio to osim_code

def send_folder_name(msg):
    s = socket.socket()         # Create a socket object
    s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    host = socket.gethostname() # Get local machine name
    print host
    port = 50003
    s.connect((host, port))
    s.send(json.dumps(msg))
    s.close()    

send_folder_name(mypath)

def one_step_osim(neuroid_osim_msg,testing_mode):
    s = socket.socket()         # Create a socket object
    s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    host = socket.gethostname() # Get local machine name
    print host
    port = 50003
    s.connect((host, port))

    # format for neuiroid_osim_msg is following:
    # [{"msucle_name":16,"activation":fact},{"muscle_name":17,"activation":eact}]
    s.send(json.dumps(neuroid_osim_msg))
    
    if testing_mode == "open_loop":
       osim_neuroid_msg = "open_loop testing underway, NO feedback from the musculoskeleton" 
       #print osim_neuroid_msg
    elif testing_mode == "close_loop":
         #receive afferent firings in the following
         print "close_loop"
         jsstr = s.recv(1024000)
         jsmsg = json.loads(jsstr)
         osim_neuroid_msg = jsmsg
    s.close()    
    return osim_neuroid_msg

class Neuroid:
    """
    class: Neuroid
    represents an instance of NEURON simulation

    The functions in this file are invoked when the user loads a simulation setup
     json file from the browser interface.
    An instance of this class is created to run the experiment.
    An experiment may have multiple simulation runs and all of those are
     handled in this file
    On successful completion of experiemnt simulation, This class also stores the 
     results in npz files, which is later used by plot.py
    """

    def __init__(self):
        """
        function: __init__

        sets up the NEURON HOC environment and initialize variables man_L5_GasSol9_L_aMot_gaslat_cell
        """
        self.h = h
        # neuroid.hoc is generated by the nodejs server code
        #  It uses the spine.json and setup json file to create this
        #  neuroid.hoc represents the model in a hoc file format,
        #  while this file parses the setup json file and performs experiment
        #  on the hoc model
        
        # setup json file where the experiment details are present
        setupf = open(mypath+"/setup.json") 
        self.setup = json.loads(setupf.read())
        setupf.close()
        
        # load neuroid.hoc
        self.h.xopen(mypath+"/neuroid.hoc")
        self.h('objref pc')
        self.h('pc = new ParallelContext()') #comment@madhav non functional call because parallel is not in use
        self.h('PcID = pc.id // for python') #comment@madhav non functional call because parallel is not in use
        self.h('Nhost = pc.nhost // for python')
        self.h('celsius=37')
        self.h('dt=0.05')
        self.h('v_init=-65')
        self.simid = 0
        self.dt = self.setup["runs"]["dt"]
        print "line tester", len(self.setup), self.setup.keys()
        #comment@madhav this section need to be extended for generic cases
        ## motoneuron recruitment as a function of ees stimulation current
        ## derived from [moraud 2016]
        ##xls = pd.read_excel(mypath+"/recruitment.xlsx","recr")
        #xls = xls.fillna('')
        #self.recruitment = xls.to_dict(orient='list')
        #self.region_recruitment_map = \
           #{"Human_L4_CFl9_L_AlphaMoto_TibialisAnterior": "Mn_Flex",
           #"Human_L4_L4_drg_L_IaAfferent_TibialisAnterior": "Ia_Flex",
           #"Human_L4_L4_drg_L_IIAfferent_TibialisAnterior": "II_Flex",
           #"Human_L5_CEx9_L_AlphaMoto_Gas": "Mn_Ext",
           #"Human_L5_L5_drg_L_IaAfferent_Gas": "Ia_Ext",
           #"Human_L5_L5_drg_L_IIAfferent_Gas": "II_Ext"}
        self.vrecord = {}
        self.iclrecord = {}

        # handle LFP and OpenSim flags in setup json
        if "lfp" in self.setup["setup"] and self.setup["setup"]["lfp"]["enable"] == "True":
            self.lfp = lfp.LFP(self.h)
        self.osim = False #why is this ??
        if "opensim" in self.setup["setup"] and self.setup["setup"]["opensim"]["enable"] == "True":
            self.osim = True
       

    #def __del__(self):
        #"""
        #function: __del__

        #cleans up the NEURON HOC environment
        #"""
        #self.h('{pc.runworker()}')
        #self.h('{pc.done()}')
        #self.h('t2 = startsw() // timer')
        #self.h.quit()

    def _set_simid(self, i):
        """
        function: __set_simid
        sets the simulation id

        An experiment may involve multiple simulation runs, each with different parameters
        setup.json file contains details of number of simulations for an experiment
        This function simply sets the current simulation run id into a class variable
        """
        self.simid = i

    def reset(self):
        """
        function: reset

        reset the state of system before a simulation run starts
        """
        self.h.finitialize(-65)
        self.tskip = 0
        self.h.t = 0
        self.h.tstop = self.setup["runs"]["tstop"][self.simid]
        #comment@madhav: network_init will be required only when there is a 
        #defined concensus what neuronal targets are connected to 
        #self.network_init(reset=1)
        
        self.input = {
          "ees": {},
          "iclamp": {}
        }
        for response in self.setup["responses"]:
            if response["type"] == "variable":
                ncells = int(eval("h.n"+response["target"]["obj"]))
                self.vrecord[str(self.simid) + "_" + response["type"]+"_"+response["id"]] = np.zeros((int(self.h.tstop/self.dt),ncells))
        self.times_of_interest = []
        if "singlecell" in self.setup["setup"]:
            pass
            
        if "lfp" in self.setup["setup"] and self.setup["setup"]["lfp"]["enable"] == "True":
                if self.simid in  self.setup["setup"]["lfp"]["plot_run_ids"]:
                    position = self.setup["setup"]["lfp"]["position"]
                    self.lfp.lfp_init(position)
       
    def _set_input_play(self):
        """
        function: _set_input_play

        This function writes the timeseries iclamp values into vectors
        NEURON allows these vectors to be "played" during simulation
        """
        def get_input(itype, iid):
            for inp in self.setup["inputs"]:
                if inp["type"] == itype and inp["id"] == iid:
                    return inp
        
        run_params = self.setup["runs"]["run_params"][self.simid]
        if "input" in run_params:
            rp_inp = run_params["input"]
        for idef in rp_inp:
            if idef["type"] == "iclamp":
                inp = get_input(idef["type"] ,idef["id"])
                icl_inp_key = str(self.simid)+"_"+inp["type"]+"_"+inp["id"]
                current = self.input["iclamp"][icl_inp_key][:,0]
                fname = mypath+"/save_" + str(self.simid) + "_" + inp["type"] + "_" + inp["id"]
                np.save(fname, self.input["iclamp"][icl_inp_key])
                self.h('objref myvec_icl_'+inp["id"])
                if inp["id"] == "0":
                    h.myvec_icl_0 = h.Vector(self.input["iclamp"][icl_inp_key][:,0])
                elif inp["id"] == "1":
                    h.myvec_icl_1 = h.Vector(self.input["iclamp"][icl_inp_key][:,0])
                elif inp["id"] == "2":
                    h.myvec_icl_2 = h.Vector(self.input["iclamp"][icl_inp_key][:,0])
                self.h('set_iclamps(myvec_icl_'+inp["id"]+', stim_objlist_'+  inp["type"] + "_" + inp["id"] +')')
                    
    def modparams_override(self, modparlist):
        """
        function: modparams_override
          modparlist - list of parameters that needs to be overridden

        This function overrides the model parameters (defined in mod files)
        This is useful when an experiment nees to be run by changing some 
         parameters from mod file
        """
        for modpar in modparlist:
            reg = modpar["region"]
            seg = modpar["segment"]
            modstr = modpar["modset"]
            ncells = int(eval("h.n"+reg))
            for i in range(ncells):
                nseg = eval("h."+reg+"_cells["+str(i)+"].n"+seg)
                for j in range(int(nseg)):
                    hocstr = reg+"_cells["+str(i)+"]."+seg+"["+str(j)+"]"+\
                           "{ "+modstr+" }"
                    print hocstr
                    self.h(hocstr)
                    
    #function to reset the netstim stimulation of the 
    #for the activation of motoneuons, we can call EES as proxy to cortical drive
    #randomize the stimulaion affinity to the motoneuron cluster
    def reset_ees_stim(self, stim_obj, wt):
        ees_targs = eval(stim_obj)
        for i in range(int(ees_targs.count())):
            cg_targ = ees_targs.object(i)
            for j in range(int(cg_targ.count())):
                    cg_targ.object(j).weight[0] = wt
                    
                    
    def reset_ees_stim_rand(self, stim_obj, rand_dist):
        ees_targs = eval(stim_obj)
        for i in range(int(ees_targs.count())):
            cg_targ = ees_targs.object(i)
            for j in range(int(cg_targ.count())):
                if rand_dist == 'uniform':
                    # use a value from uniform distribution 
                    rand_wt = np.random.uniform(0,1)
                    cg_targ.object(j).weight[0] = rand_wt
                    print cg_targ.object(j).weight[0]
                    
    def reset_ees_stim_noise(self, stim_obj, rand_dist):
        ees_targs = eval(stim_obj)
        for i in range(int(ees_targs.count())):
            cg_targ = ees_targs.object(i)
            for j in range(int(cg_targ.count())):
                if rand_dist == 'uniform':
                    # use a value from uniform distribution 
                    rand_wt = np.random.uniform(0,1)
                    cg_targ.object(j).noise[0] = rand_wt
                    print cg_targ.object(j).noise[0]
    
    #randomize the spike arrival time within a time window for all the cells
    def reset_ees_stim_delay(self):
        #number of cell the stimulation has to reset
        #per_cells is [0-1]
        #obtain the setup['reset_stims'] from setup.json
        reset_dict = self.setup['reset_stims'] 
        for each in reset_dict:
            stim_obj = each['stim_obj']
            ees_targs = eval(eval(stim_obj)) #tells how many cells are targetted by this ees oject == number of cells
            #print 'number_of_cells=', ees_targs.count()  
            ncells = ees_targs.count()*each['per_cells'] 
            
            for j in range(int(ncells)):
                #cg_targ = ees_targs.object(i)
                #for j in range(int(cg_targ.count())):
                # use a value from uniform distribution 
                if not each['delay_start_time'] and each['delay_end_time'] :
                    pass
                elif each['dealy_start_time']> 0 and each['delay_end_time']==0:
                     ees_targs.object(j).delay = each['dealy_start_time']
                else:
                    rand_delay_time = np.random.uniform(each['delay_start_time'],each['delay_end_time'])
                    #print ees_targs.object(j).delay
                    ees_targs.object(j).delay = rand_delay_time
                #reset weight of the object    
                ees_targs.object(j).weight[0] = each['weight']
                #print ees_targs.object(j).delay, ees_targs.object(j).weight[0]
                
    #functions to control the afferent feedback to the spinalcircuit
        
        

#Add more arguments to run
    #def run(self, moto_osim_map, osim_drg_map, proprio='off, motoneurons')
    def run(self):
        
        """
        function: run

        This function performs the NEURON simulation
          - Initializes python variables that store the spike train and inputs in every time step
          - In a while loop:
            - Advance the simulation by one time step
            - Calculate the activation for relevant muscles using motoneuron axon potentials
            - Advance the musculo-sketal model by one step
            - Afferent firing is used to stimulate the IN and MN, closing the loop
            - Update python variables with the recorded values for that timestep
        """
        print "RUN section began"
        

        def calc_cum_neu_act(cum_neu_act_dat, all_spk_dat, t_iterator):
            
            """
            #descrete to continous activity calculation by sartori et.al. and Lloyd et.al.
            # inputs: spike data of all the motoneurons of a cell_group, previous time histories of two neural activation data, recursive c1, c2 coefficients. 
            # outputs: neural activation value, 
            """
            #recursive coefficients c1, c2, to be modelled for each muscle type
            c1 = -0.5; c2 = -0.5; e_delay = 10
            
            beta1 = c1+c2; beta2 = c1*c2; alpha=1.0+beta1+beta2
            cum_spk_val = np.sum(all_spk_dat[t_iterator-int((e_delay/self.dt))])
            neu_act = alpha*cum_spk_val - beta1*cum_neu_act_dat[t_iterator-1] - beta2*cum_neu_act_dat[t_iterator-2]
            return neu_act
        
        #function to convert cumulative motoneuronal activity to muscle activity
        a = -3
        fxn = lambda x : (math.exp(a*x) -1)/(math.exp(a)-1)
        #fxn = np.vectorize(fxn)
        
        def calc_spike_freq(spikes, count, time_window, per_cells):
            """
            function: calc_spike_freq
            spikes - spike train as a python list
            count - current simulation step number

            Calculates the spike frequency (in Hz) given the spike train
            The frequency is obtained using the spike train over the past 30ms
            """
            avg_time = time_window #(ms)
            nrows = int(avg_time/self.dt) # for 1ms
            ncells = spikes.shape[1]
            spikes = spikes[count-nrows+1:count,:]
            nspikes = np.sum(spikes)/ncells #number average spike frequency
            sfreq = (1000.0*nspikes)/avg_time
            return sfreq

        def calc_activation(freq,prev_act):
            """
            function: calc_activatin
              freq - frequency of spike train
              prev_act - previous activation of the muscle

            Calculates the activation (a value between 0.0 and 1.0) for the muscle
            This is sent to OpenSim to activate corresponding muscle
            The new calculated value uses a (1-alpha) update to reduce noise
            """
            act = 1.0/(1+math.exp(-0.2*(freq-20)))
            alpha = 0.2
            act = alpha*act + (1.0-alpha)*prev_act
            return act
        
        def find_drg_name(idx):
            name = osim_drg_map.iloc[idx]['target_drg']
            return name
    
        def set_afferent_stim_Hz(osim_neuroid_msg):
            for each in osim_neuroid_msg:
                drg_name = find_drg_name(int(each))
                drg_stim_list = eval("h." + drg_name + "_stim")
                #drg_stim.pp.number = 10*osim_neuroid_msg[each]      #temporary multiplier remove or modify later
                if osim_neuroid_msg[each] > 0.0:
                   drg_stim_list.pp.interval = int(1000/osim_neuroid_msg[each])
                   print drg_stim_list.pp.interval
                
        def set_afferent_stim_wt(osim_neuroid_msg,wt):
            for each in osim_neuroid_msg:
                drg_name = find_drg_name(int(each))
                #print drg_name
                drg_stim_list = eval("h." + drg_name + "_stim_list")
                if osim_neuroid_msg[each] > 0.0:
                    for i in range(0,len(drg_stim_list)):
                        drg_stim_list.object(i).weight[0] = wt
                        #print "weight=", drg_stim_list.object(i).weight[0]
        
        #print load_osim_drg_map

        # Initialize python variables to record variables during simulation
        # If the input type is "iclamp", the input stimulation amplitude is
        #  calculated for each time step and stored in a hoc Vector
        #  This is done so that the Vector can be "played" during simulation
        #  run
        #self._set_input_play()
        self.time = []
        self.spikes = {}
        self.ees_inp = {}
        self.aff = {} #append all simid to the afferent dictionary
        self.tskip = 0
        self.h.finitialize(-65)
        #self.avg_memV = h.List()
        nts = int((self.h.tstop-self.tskip)/self.dt)
 
        #create a time array and use ths array as index to create dataframes
        #use this mostly  
        self.motoneurons = self.setup["motoneurons"]
        self.time_array = np.linspace(0,h.tstop,int(self.h.tstop/self.dt))
        self.moto_act_df = pd.DataFrame(0, index = self.time_array, columns = self.motoneurons)
        self.muscle_act_df = pd.DataFrame(0, index = self.time_array, columns = osim_muscles)
        #self.cum_neu_act_df = pd.DataFrame(0, index = self.time_array, columns = osim_muscles)
        
        #convert dtype of dataframes to floating types
        self.muscle_act_df = self.muscle_act_df.astype(float)
        #self.cum_neu_act_df = self.cum_neu_act_df.astype(float)
        '''
        #open dataframes for each of the variables required
        
        #pull the motoneuron_groups and drg_groups list from the setup["motoneurons"], setup["drg_neurons"]
        #obtain this from the spine.json at later stage
        self.drg_neurons = osim_drg_map["target_drg"].to_list()
        self.spikes_record_df = pd.DataFrame(0, index = self.time_array, columns = self.motoneurons)
        self.spikes_prev_df = pd.DataFrame(0, index = self.time_array, columns = self.motoneurons)
        self.aff_df = pd.DataFrame(0, index = self.time_array, columns = self.drg_neurons)
        self.aff_df_prev = pd.DataFrame(0, index = self.time_array, columns = self.drg_neurons)
        self.muscle_act_df = pd.DataFrame(0, index self.time_array, columns = self.muscle_names)
        self.muscle_prev_act_df = pd.DataFrame(0, index self.time_array, columns = self.muscle_names)
        
        #fill these at later stage
        #self.osim_vars_df = pd.DataFrame()
       
        
        #call motoneurons from osim_neuroid_map and load them to empty motoenruon_act dataframe
        #assign zeros array to each of them
        for each_motoneuron_grp in range(len(neuroid_osim_map['source_motoneuron'])):
            muscle_name = neuroid_osim_map.iloc[each]['muscle_name']
            #muscle_act_df[muscle_name] = np.zeros(nts)
            muscle_prev_act_df[muscle_name] = 0
        
        
        #parameters to track for osim load them here                   
        osim_vars_df["aang"] = np.zeros(nts)
        '''
        
        self.osim_vars = {"aang": np.zeros(nts),
                          "fact": np.zeros(nts),
                          "eact":np.zeros(nts)}
        
        #create empty numpy arrays for just motoneurons to fill them at later time
        #create empty numpy arrays for cumulative spikes calculation with time
        self.moto_spikes = {}
        self.cum_neu_act_dat = {}
        for moto_neuron_grp in self.motoneurons:
            moto_spikename = "spike" + "_" + moto_neuron_grp #eg: spike_Human_L2_Q9_L_aMotrecf #190 motoneurons
            ncells = int(eval("h.n"+ moto_neuron_grp))
            self.moto_spikes[moto_spikename] = { "record": np.zeros((nts,ncells)), #time_bin x cell_num #record contains a particular cell_groups's all the spikes vs time
                                           "prev": np.zeros(ncells) }
            self.cum_neu_act_dat[moto_spikename] = {"record" : np.zeros((nts))}
            
        #choose testing modes close loop or open loops here
        #if open_loop donot create the dgrs and donot record the afferent feedback
        #if close_loop record create drg variables and record the afferent feedbacks
        self.drg_neurons = {} 
        #if self.setup["setup"]["testing_mode"]["open_loop"] == "True":
            #pass
        
        #this section still remain to track the setup["responses"] # use this section to tract the spiking activity of any neurons and use for rasters
        for response in self.setup["responses"]:
            if response["type"] == "spike":
                spikename = response["type"]+"_"+response["id"]
                ncells = int(eval("h.n"+response["target"]["region"]))
                self.spikes[spikename] = { "record": np.zeros((nts,ncells)),
                                           "prev": np.zeros(ncells) }
                
        #this section for now can be same
        for inp in self.setup["inputs"]:
            if inp["type"] == "ees":
                self.ees_inp[str(self.simid) + "_" + inp["type"]+"_"+inp["id"]] = np.zeros((int(self.h.tstop/self.dt),1))
                
            
                
        #no changes required
        if not "singlecell" in self.setup["setup"]:
            pass
            #for all the afferents listed in the osim_drg_map
            #for each_afferent in afferents:
            
            '''
            for each_drg in osim_drg_map['target_drg']:
                self.aff_df[each_drg] = np.zeros((int(self.h.tstop/self.dt),1))
            '''
            #problematic section: this calls simid and puts up with 
            #if self.setup["setup"]["testing_mode"]["open_loop"] == "True":
                
                #pass
            
                #self.aff[str(self.simid) + "_flex_Ia"] = np.zeros((int(self.h.tstop/self.dt),1))
                #self.aff[str(self.simid) + "_ext_Ia"] = np.zeros((int(self.h.tstop/self.dt),1))
                #self.aff[str(self.simid) + "_flex_II"] = np.zeros((int(self.h.tstop/self.dt),1))
                #self.aff[str(self.simid) + "_ext_II"] = np.zeros((int(self.h.tstop/self.dt),1))
                #self.aff[str(self.simid) + "_aangle"] = np.zeros((int(self.h.tstop/self.dt),1))
            
            '''
            for each_drg in osim_drg_map['target_drg']:
                self.aff_df_prev[each_drg] = 10
            '''
              
            #not sure what these are??
            #fpps_prev = 10
            #epps_prev = 10
            #fact_prev = 0
            #eact_prev = 0

        # Initialize NEURON environment
        #self.h.stdinit()
        count = 0
        #self.h.pc.psolve(self.h.t+self.tskip)
        mparams = [] 
        # SEARCHING is set to True if we are using main.py in the parameter search setting
        # This will be set to False for most use cases
        if SEARCHING==True:
            fname = mypath+"/search_main.txt"
            fhand = open(fname, "r")
            vals = fhand.readlines()
            vals = vals[self.simid].strip()
            fhand.close()
            print vals.split(",")
            for v in vals.split(","):
                mname,mval=v.split(":")
                mp =  {"region":"Human_L5_CEx9_L_AlphaMoto_Gas",
                     "segment":"dendrite",
                     "modset": str(mname)+"="+str(mval)
                    }
                mparams.append(mp)
        else:
            rp = self.setup["runs"]["run_params"][self.simid]
            if "modparams" in rp:
                mparams = rp["modparams"]
            
        # Override the model parameters with the values provided by
        # user in the setup json file
        if len(mparams) > 0:
            self.modparams_override(mparams)

        # The main simulation loop
        #while (self.h.t<self.h.tstop) and (count < nts):
        while (self.h.t<self.h.tstop) and (count < nts): 
               #if count < nts:
                   #break
            # If the input type is "ees", call the set_interval function
            #  of ees object with appropriate value
            print "while loop started,iteration = ", count
            #print "time_by_array=", self.time_array[count]
            print count, nts, self.h.tstop
            #self._set_input(count)
            self.h.pc.psolve(self.h.t+self.dt)
            '''
            #create empty dictionaries to store freqs and activations for each time step in loop
            self.moto_grp_freq = pd.DataFrame(columns = neuroid_osim_map['source_motoneuron'].tolist())
            self.mus_acts = pd.DataFrame(columns = neuroid_osim_map['source_motoneuron'].tolist())
            '''
            self.moto_osim_musc_map_sim = load_neuroid_osim_map.copy()
            self.moto_osim_musc_map_sim.set_index("source_motoneuron", inplace=True)
            self.moto_osim_musc_map_sim["moto_firing_freq"] = 0.0
            self.moto_osim_musc_map_sim["musc_activation"] = 0.0
            #self.moto_osim_musc_map_sim["musc_activation"] = pd.to_numeric(self.moto_osim_musc_map_sim["musc_activation"], errors='coerce')
            #self.moto_osim_musc_map_sim["moto_firing_freq"] = pd.to_numeric(self.moto_osim_musc_map_sim["moto_firing_freq"], errors='coerce')
            
            if "singlecell" in self.setup["setup"]:
                pass
            else:
                
                # If experiment needs to interact with a OpenSim musculo-skeletal model (opensim)
                # Calculate the spike frequency using the average membrane potentials
                # Calculate the "activations" for the corresponding muscles
                # (This is a value between 0 and 1, as expected by OpenSim)
                # Advance the OpenSim model by one step
                # Using the afferent PPS, set the stimulation of feedback loop
                if self.osim == True:

                    #three steps###########################old method###################### 
                    #step 1 : calculate spikes_freq for each motoneuron passed in setup.json 
                    #step 2 : calculate the muscle_activation that need to be sent to osim model
                    #step 3 : synthesize the neuroid_osim message 
                    
                    #######################################alternate method################
                    ##################method obtained from satori et al and Lloyd et.al####
                    #step1 : get the cumulative spiking activity
                    #step2 : caluclate the neural activity 
                    #step3 : calculate the muscle activity
                    ####################################################################### 
                    
                    #step 1 and step 2
                    for each_moto_grp in self.moto_spikes:
                        #print each_moto_grp
                        moto_grp_name = each_moto_grp.lstrip('spike_') #obtain the moto cell group by stripping the ('spike_')
                        #print moto_grp_name
                        
                        #print self.moto_spikes["spike_Human_L5_GasSol9_L_aMot_gaslat"]["record"]
                        #calculate the fring frequency at every time step or at given intervals, determine from system understanding
                        #calc_spike_freq(spikes, count, time_window, per_cells
                        moto_grp_firin_freq = calc_spike_freq(self.moto_spikes[each_moto_grp]["record"],count,self.setup["runs"]["window"],1)
                        #print moto_grp_firin_freq
                        
                        #moto_osim_musc_map_sim is filled at every time step
                        #update the osim_musc_map_sim dataframe using enssemble firing frequency of a particular cell group
                        self.moto_osim_musc_map_sim.at[moto_grp_name,'moto_firing_freq'] = moto_grp_firin_freq #identify what motoneuron and update only those 
                        
                        #calculate the activation that needed to be sent to osim using this fnx #calc_activation(freq,prev_act)
                        ###########old_method#########################
                        #here prev_act is previous time_step activation
                        #prev_act_moto_grp = self.moto_act_df.loc[self.time_array[count-1],moto_grp_name]
                        #curr_act_moto_grp = calc_activation(moto_grp_firin_freq,prev_act_moto_grp)
                        #print curr_act_moto_grp
                        
                        #calculate cumulative spiking activity
                        ############new_method#########################
                        cum_neu_act_val = calc_cum_neu_act(self.cum_neu_act_dat[each_moto_grp]["record"], self.moto_spikes[each_moto_grp]["record"], count)
                        curr_act_moto_grp = fxn(cum_neu_act_val)
                        
                        #update the cumulative neural activity
                        ###############################################
                        self.cum_neu_act_dat[each_moto_grp]["record"][count] = float(cum_neu_act_val)
                        
                        #update the muscle activation dataframe #track by iterator i.e count and motoneuron string
                        #self.moto_osim_musc_map_sim.at[moto_grp_name,'musc_activation'] = float(curr_act_moto_grp)
                        self.moto_osim_musc_map_sim.at[moto_grp_name,'musc_activation'] = float(moto_grp_firin_freq/100)
                        #print self.moto_osim_musc_map_sim
                        
                    #get activations by all motoneuron groups that are targetted to a particular muscle.
                    #moto_osim.loc[moto_osim["muscle_name"]=='gaslat_l']['muscle_acts'].mean()
                    #sysnthesize osim message in this loop
                    #step 3
                    neuroid_osim_msg = []
                    for each_osim_musc in osim_muscles:
                        #print self.moto_osim_musc_map_sim
                        #get the average activation from the moto_osim_musc_map_sim- segmental summation or mean
                        osim_muscle_act = self.moto_osim_musc_map_sim.loc[self.moto_osim_musc_map_sim["muscle_name"]== each_osim_musc]['musc_activation'].mean()
                        
                        #print self.moto_osim_musc_map_sim.loc[self.moto_osim_musc_map_sim["muscle_name"]== each_osim_musc]['musc_activation'].dtypes
                        
                        #do mean or max activation depending on the requirement
                        #osim_muscle_act = np.mean(osim_muscle_act_vals) 
                        
                        #print osim_muscle_act
                        #push osim_muscle_act values to time vs muscles_dataframe
                        #append the activation to muscle_act_df to store the data
                        #print "time_by_array=", self.time_array[count]
                        #print "time_by_simulation=", self.h.t
                        self.muscle_act_df.at[self.time_array[count],each_osim_musc] = float(osim_muscle_act) 
                        #print self.muscle_act_df.loc[self.time_array[count],each_osim_musc]
    
                        #extract osim muscle_name and id
                        osim_muscle_id = self.moto_osim_musc_map_sim.loc[self.moto_osim_musc_map_sim["muscle_name"]== each_osim_musc]['index_number'].to_list()[0]

                        #neuroid_osim message
                        neuroid_osim_msg.append({'id' : osim_muscle_id, 'act': osim_muscle_act})
                    
                    #print neuroid_osim_msg
                    #for each in neuroid_osim_msg:
                        #if math.isnan(float(each['act'])) != True:
                            #print each['id']
     
                    #discontinue this code
                    #ffreq = calc_spike_freq(self.spikes["spike_1"]["record"],count)
                    #efreq = calc_spike_freq(self.spikes["spike_0"]["record"],count)
               
                    #fact = calc_activation(ffreq,fact_prev)
                    #eact = calc_activation(efreq,eact_prev)   
                    #fact_prev = fact
                    #eact_prev = eact
                    #fpps = fpps_prev
                    #epps = fpps_prev 
                
                    #print ffreq, efreq, fact, eact
                    
                    #neuroid_osim_msg = [{"msucle_name":16,"activation":fact},
                                         #{"muscle_name":17,"activation":eact}]
                                         
                    #ommit the zero'th step and ca
                    if count % 5 == 0:
                        
                        osim_neuroid_msg = one_step_osim(neuroid_osim_msg,testing_mode=self.setup["setup"]['testing_mode']) #push this open_loop/close_loop option to the setup.json
                        #print osim_neuroid_msg 
                        if self.setup["setup"]['testing_mode'] == 'close_loop':
                            
                            #to turn on the designated afferent 
                            set_afferent_stim_wt(osim_neuroid_msg,1)
                            
                            #to turn on set the afferent frequency 
                            set_afferent_stim_Hz(osim_neuroid_msg)
                        #if count > 3000:
                           #set_afferent_stim_Hz(osim_neuroid_msg)
                           #set_afferent_stim_wt(osim_neuroid_msg,randon.uniform(5,10))
                        
                        #set afferent feed back at different times 
                        ################################################################
                        ################################################################
                        #Afferent feedback block comes here#############################
                        #insert design a function/ or call here#########################        
                        ################################################################        
                else:
                    # If we are using our in-house ankle model, call ankle_adv_hoc
                    # to advace the model by one step
                    self.h('ankle_adv_hoc(avgFlexV, avgExtV, taga_pps)')
                    
                # If LFP is enabled, advance the LFP calculations by one step
                if "lfp" in self.setup["setup"] and self.setup["setup"]["lfp"]["enable"] == "True":
                    if self.simid in  self.setup["setup"]["lfp"]["plot_run_ids"]:
                        self.lfp.lfp_advance()


            #Store the "responses", "inputs" and "spike trains" in python variables
            #for current step
            for response in self.setup["responses"]:
                if response["type"] == "variable":
                    ncells = int(eval("h.n"+response["target"]["obj"]))
                    for i in range(int(ncells)):
                        self.vrecord[str(self.simid) + "_" + response["type"]+"_"+response["id"]][count,i] = eval('h.'+response["target"]["obj"]+'_cells[' + str(i) + '].'+response["target"]["member"])
            
            
            #for inp in self.setup["inputs"]:
                #if inp["type"] == "ees":
                    #self.ees_inp[str(self.simid) + "_" + inp["type"]+"_"+inp["id"]][count][0] = 1000.0/int(eval("h.stim_ees_"+str(inp["id"])+".get_interval()"))
            #following reset of Afferent NetStims to be done while testing the close loop cases
            #this section counts spikes of the cells that are mentioined in setup["response"]["veariable"]:spike
            for spk in self.spikes:
                nspikes = eval("h.record_"+spk)
                ncells = self.spikes[spk]["prev"].shape[0]
                for i in range(int(ncells)):
                    self.spikes[spk]["record"][count,i] = nspikes[i].size() - self.spikes[spk]["prev"][i]
                    self.spikes[spk]["prev"][i] = nspikes[i].size()
            
            #this sections counts the spikes for all the motoneurons passed in the setup.json and are pushed into respective numpy arrays
            for each_moto_spk in self.moto_spikes:
            #for each_moto_grp in self.spikes:
                spike_vec = eval("h.record_"+ each_moto_spk) #evaluate the hoc statements, #here assign the hoc's vector class to spike_vec 
                ncells = eval("h.n" + each_moto_spk.lstrip('spike_')) #here assign the number of cells -------------
                for i in range(int(ncells)):
                    self.moto_spikes[each_moto_spk]["record"][count,i] = spike_vec[i].size() - self.moto_spikes[each_moto_spk]["prev"][i]
                    self.moto_spikes[each_moto_spk]["prev"][i] = spike_vec[i].size()
                    
            self.time.append(self.h.t)
            count = count+1
        #print count
    

    def output(self):
        """
        function: output

        Save the results of simulation into npz files
        This function parses the setup["responses"] section to identify the
         variables that have to be saved into npz files.  Inputs defined in
         setup["inputs"] section are also saved
        """
        def save_variable(response):
            """
            function: save_variable
              response - setup["response"][i]

            This function saves a NEURON variable (Vector) into npz files
            """
            resp_cg = eval("h.record_"+response["type"]+"_"+response["id"])
            variable_cg = np.zeros((len(self.time),len(resp_cg)))
            for i in range(len(resp_cg)-1):
                vvec = resp_cg[i]
                for j in range(0,int(vvec.size())-int(self.tskip/self.dt)-1):
                    variable_cg[j][i] = vvec.x[j]
            fname = mypath + "/save_"+ str(self.simid) + "_" + response["type"]+"_"+response["id"]
            np.save(fname, self.vrecord[str(self.simid)+'_'+response["type"]+"_"+response["id"]])
        
        #use this to record any other neuron other moto neuron 
        #works only if the neuron is not an artificial one
        def save_spike(response):
            """
            function: save_spike
              response - setup["response"][i]

            This function saves the recorded spike trains
            into npz files
            """
            spikename = response["type"]+"_"+response["id"]
            spikes_cg = self.spikes[spikename]["record"]
            fname = mypath + "/save_"+ str(self.simid) + "_" + response["type"]+"_"+response["id"]
            np.save(fname, spikes_cg)
            
        def save_moto_spike(response):
            """
            function: to save all motoneuron's spiking data invariably for all motoneurons
            input: pass the response requested for in the setup.json 
            output: all 
            """
            spikename = "spike_" + response["target"]["region"]  #spike_Human_L2_Q9_L_aMotrecf
            spikes_cg = self.moto_spikes[spikename]["record"]
            fname = mypath + "/save_"+ str(self.simid) + "_" + spikename 
            np.save(fname, spikes_cg)
            
                        
        def save_voltage(response):
            """
            function: save_voltage
              response - setup["response"][i]

            This function saves the recorded voltages (membrane potential) 
            into npz files	
            """
            resp_cg = eval("h.record_"+response["type"]+"_"+response["target"]["region"]+"_"+response["target"]["segment"]+"_"+response["id"])
            voltage_cg = np.zeros((len(self.time),len(resp_cg)))
            for i in range(len(resp_cg)):
                vvec = resp_cg[i]
                for j in range(0,int(vvec.size())-int(self.tskip/self.dt)-1):
                    voltage_cg[j][i] = vvec.x[j]
            fname = mypath + "/save_"+ str(self.simid) + "_" + response["type"]+"_"+response["target"]["region"]+"_"+response["target"]["segment"]+"_"+response["id"]
            np.save(fname, voltage_cg)
            
        def save_muscle_act():
            fname = mypath + "/muscle_act_data_"
            self.muscle_act_df.to_excel(fname+".xlsx")

        # parse the setup["responses"] section and invoke appropriate
        #  functions to save the results into npz files
        for response in self.setup["responses"]:
            if response["type"] == "voltage":
                save_voltage(response)
            elif response["type"] == "spike":
                save_spike(response)
                save_moto_spike(response)
                save_muscle_act()
            elif response["type"] == "variable":
                save_variable(response)

        # parse the setup["inputs"] section and invoke appropriate
        #  functions to save the inputs into npz files
        # Note that if the type is "iclamp" the variable storing the 
        #  current stimulation is stored in _set_input_play function itself
        
        #for inp in self.setup["inputs"]:
            #if inp["type"] == "ees":
                #eesname = "ees_" + str(inp["id"])
                #inp_ees = self.ees_inp[str(self.simid) + "_" + inp["type"]+"_"+inp["id"]]
                #fname = mypath + "/save_"+ str(self.simid) + "_" + inp["type"]+"_"+inp["id"]
                #np.save(fname, inp_ees)

        # If the simulation is not for "singlecell" (i.e., not a single cell
        #  physiology experiment), then the biomechanical model is interfaced to
        #  NEUROiD.  So, save the variables corresponding to that model too
        #if not "singlecell" in self.setup["setup"]:
            #fname = mypath + "/save_"+ str(self.simid) + "_flex_Ia"
            #np.save(fname, self.aff[str(self.simid) + "_flex_Ia"])
            #fname = mypath + "/save_"+ str(self.simid) + "_ext_Ia"
            #np.save(fname, self.aff[str(self.simid) + "_ext_Ia"])
            #fname = mypath + "/save_"+ str(self.simid) + "_flex_II"
            #np.save(fname, self.aff[str(self.simid) + "_flex_II"])
            #fname = mypath + "/save_"+ str(self.simid) + "_ext_II"
            #np.save(fname, self.aff[str(self.simid) + "_ext_II"])
            #fname = mypath + "/save_"+ str(self.simid) + "_aangle"
            #np.save(fname, self.aff[str(self.simid) + "_aangle"])
        
        # Save the variable containing simulation time steps
        fname = mypath + "/save_time"
        np.save(fname, self.time)
        fthand = open(mypath + "/time.dat", "w")
        for x in range(len(self.time)):
            fthand.write(str(self.time[x])+"\n")
        fthand.close()

        # Save the variable from LFP simulation if that was enabled
        if "lfp" in self.setup["setup"] and self.setup["setup"]["lfp"]["enable"] == "True":
            if self.simid in  self.setup["setup"]["lfp"]["plot_run_ids"]:
                self.lfp.lfp_save(mypath, self.time, self.simid)

# This file takes no command line arguments
if __name__ == '__main__':
    # Create an instance of Neuroid
    neuroid = Neuroid()
    print "yes"
    # NEUROiD can support a single simulation run for an experiment
    #  or multiple simulation runs for an experiment
    # For e.g., to obtain the spinal reflex recruitment curves, we need to run
    #  multiple simulation runs by changing the input stimulation current
    #  NEUROiD allows a single setup json file to specify all the simulation
    #  runs and perform the experiment
    # len(neuroid.setup["runs"]["tstop"]) is the number of simulation runs for
    #  current experiment
    num_simulation_runs = len(neuroid.setup["runs"]["tstop"])
    for i in range(num_simulation_runs):
        print("Starting simulation run: "+str(i+1)+" of "+str(num_simulation_runs))
        sys.stdout.flush()
        neuroid._set_simid(i)
        
        print i

        # Reset the state of variables for every simulation run
        neuroid.reset()

        # parse the "inputs" section of setup json    
        #neuroid.parse_input()
        
        # reset the stimulation weight bfore beginning of the simulation
        #neuroid.reset_ees_stim('h.stim_objlist_ees_0', 0) #push this to setup.json
        #neuroid.reset_ees_stim_rand('h.stim_objlist_ees_0', 'uniform')
        #neuroid.reset_ees_stim_noise('h.stim_objlist_ees_0', 'uniform')
        #neuroid.reset_ees_stim_delay()
        
        # Perform simulation run
        neuroid.run()

        # save all the results from variables into npz files
        # These will later be used by plot.py
        neuroid.output()
